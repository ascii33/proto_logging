/*
 * Copyright (C) 2019 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto2";

package android.stats.mediametrics;

/**
 * Track how we arbitrate between microphone/input requests.
 * Logged from
 *   frameworks/av/services/audiopolicy/service/AudioPolicyInterfaceImpl.cpp
 *   frameworks/av/services/mediaanalytics/statsd_audiopolicy.cpp
 * Next Tag: 10
 */
message AudioPolicyData {
    optional int32 status = 1;
    optional string request_source = 2;
    optional string request_package = 3;
    optional int32 request_session = 4;
    optional string request_device = 5;
    optional string active_source = 6;
    optional string active_package = 7;
    optional int32 active_session = 8;
    optional string active_device = 9;
}

/**
 * Track properties of audio recording
 * Logged from
 *   frameworks/av/media/libaudioclient/AudioRecord.cpp
 *   frameworks/av/services/mediaanalytics/statsd_audiorecord.cpp
 * Next Tag: 16
 */
message AudioRecordData {
    optional string encoding = 1;
    optional string source = 2;
    optional int32 latency = 3;
    optional int32 samplerate = 4;
    optional int32 channels = 5;
    optional int64 created_millis = 6;
    optional int64 duration_millis = 7;
    optional int32 count = 8;
    optional int32 error_code = 9;
    optional string error_function = 10;
    optional int32 port_id = 11;
    optional int32 frame_count = 12;
    optional string attributes = 13;
    optional int64 channel_mask = 14;
    optional int64 start_count = 15;

}

/**
 * Track audio thread performance data
 * Logged from
 *   frameworks/av/media/libnblog/ReportPerformance.cpp
 *   frameworks/av/services/mediaanalytics/statsd_audiothread.cpp
 * Next Tag: 28
 */
message AudioThreadData {
    optional string type = 1;
    optional int32 framecount = 2;
    optional int32 samplerate = 3;
    optional string work_millis_hist = 4;
    optional string latency_millis_hist = 5;
    optional string warmup_millis_hist = 6;
    optional int64 underruns = 7;
    optional int64 overruns = 8;
    optional int64 active_millis = 9;
    optional int64 duration_millis = 10;

    optional int32 id = 11;
    optional int32 port_id = 12;
    optional int32 sample_rate = 13;
    optional int64 channel_mask = 14;
    optional string encoding = 15;
    optional int32 frame_count = 16;
    optional string output_device = 17;
    optional string input_device = 18;
    optional double io_jitter_mean_millis = 19;
    optional double io_jitter_stddev_millis = 20;
    optional double process_time_mean_millis = 21;
    optional double process_time_stddev_millis = 22;
    optional double timestamp_jitter_mean_millis = 23;
    optional double timestamp_jitter_stddev_millis = 24;
    optional double latency_mean_millis = 25;
    optional double latency_stddev_millis = 26;

}

/**
 * Track audio track playback data
 * Logged from
 *   frameworks/av/media/libaudioclient/AudioTrack.cpp
 *   frameworks/av/services/mediaanalytics/statsd_audiotrack.cpp
 * Next Tag: 12
 */
message AudioTrackData {
    optional string stream_type = 1;
    optional string content_type = 2;
    optional string track_usage = 3;
    optional int32 sample_rate = 4;
    optional int64 channel_mask = 5;

    optional int32 underrun_frames = 6;
    optional int32 startup_glitch = 7;

    optional int32 port_id = 8;
    optional string encoding = 9;
    optional int32 frame_count = 10;
    optional string attributes = 11;


}

/**
 * Track Media Extractor (pulling video/audio streams out of containers) usage
 * Logged from:
 *   frameworks/av/media/libstagefright/RemoteMediaExtractor.cpp
 *   frameworks/av/services/mediaanalytics/statsd_extractor.cpp
 * Next Tag: 6
 */
message ExtractorData {
    optional string format = 1;
    optional string mime = 2;
    optional int32 tracks = 3;

    enum EntryPoint {
        UNSET = 0; // For backwards compatibility with clients that don't
                   // collect the entry point.
        SDK = 1;
        NDK_WITH_JVM = 2;
        NDK_NO_JVM = 3;
        OTHER = 4; // For extractor users that don't make use of the APIs.
    }

    optional EntryPoint entry_point = 4 [default = UNSET];
    optional string log_session_id = 5;
}

/**
 * Track Media Player usage
 * this handles both nuplayer and nuplayer2
 * Logged from:
 *   frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp
 *   frameworks/av/media/libmediaplayer2/nuplayer2/NuPlayer2Driver.cpp
 *   frameworks/av/services/mediaanalytics/statsd_nuplayer.cpp
 * Next Tag: 21
 */
message NuPlayerData {
    optional string whichPlayer = 1;

    optional string video_mime = 2;
    optional string video_codec = 3;
    optional int32 width = 4;
    optional int32 height = 5;
    optional int64 frames = 6;
    optional int64 frames_dropped = 7;
    optional double framerate = 8;
    optional string audio_mime = 9;
    optional string audio_codec = 10;
    optional int64 duration_millis = 11;
    optional int64 playing_millis = 12;
    optional int32 error = 13;
    optional int32 error_code = 14;
    optional string error_state = 15;
    optional string data_source_type = 16;
    optional int64 rebuffering_millis = 17;
    optional int32 rebuffers = 18;
    optional int32 rebuffer_at_exit = 19;
    optional int64 frames_dropped_startup = 20;
}

enum StreamType {
    STREAM_TYPE_UNKNOWN = 0;
    STREAM_TYPE_OTHER = 1;
    STREAM_TYPE_PROGRESSIVE = 2;
    STREAM_TYPE_DASH = 3;
    STREAM_TYPE_HLS = 4;
    STREAM_TYPE_SS = 5;
}

enum DrmType {
    DRM_TYPE_NONE = 0;
    DRM_TYPE_OTHER = 1;
    DRM_TYPE_PLAY_READY = 2;
    DRM_TYPE_WV_L1 = 3;
    DRM_TYPE_WV_L3 = 4;
}

enum PlaybackType {
    PLAYBACK_TYPE_UNKNOWN = 0;
    PLAYBACK_TYPE_VOD = 1;
    PLAYBACK_TYPE_LIVE = 2;
    PLAYBACK_TYPE_OTHER = 3;
}

enum ContentType {
    CONTENT_TYPE_UNKNOWN = 0;
    CONTENT_TYPE_MAIN = 1;
    CONTENT_TYPE_AD = 2;
    CONTENT_TYPE_OTHER = 3;
}

enum StreamSourceType {
    STREAM_SOURCE_UNKNOWN = 0;
    STREAM_SOURCE_NETWORK = 1;
    STREAM_SOURCE_DEVICE = 2;
    STREAM_SOURCE_MIXED = 3;
}
enum NetworkType {
    NETWORK_TYPE_UNKNOWN = 0;
    NETWORK_TYPE_OTHER = 1;
    NETWORK_TYPE_WIFI = 2;
    NETWORK_TYPE_ETHERNET = 3;
    NETWORK_TYPE_2G = 4;
    NETWORK_TYPE_3G = 5;
    NETWORK_TYPE_4G = 6;
    NETWORK_TYPE_5G_NSA = 7;
    NETWORK_TYPE_5G_SA = 8;
    NETWORK_TYPE_OFFLINE = 9;
}

enum PlaybackState {
    // Playback has not started (initial state)
    NOT_STARTED = 0;
    // Playback is buffering in the background for initial playback start
    JOINING_BACKGROUND = 1;
    // Playback is buffering in the foreground for initial playback start
    JOINING_FOREGROUND = 2;
    // Playback is actively playing
    PLAYING = 3;
    // Playback is paused but ready to play
    PAUSED = 4;
    // Playback is handling a seek
    SEEKING = 5;
    // Playback is buffering to resume active playback
    BUFFERING = 6;
    // Playback is buffering while paused
    PAUSED_BUFFERING = 7;
    // Playback is suppressed (e.g. due to audio focus loss)
    SUPPRESSED = 8;
    // Playback is suppressed (e.g. due to audio focus loss) while buffering to resume a
    // playback
    SUPPRESSED_BUFFERING = 9;
    // Playback has reached the end of the media
    ENDED = 10;
    // Playback is stopped and can be restarted
    STOPPED = 11;
    // Playback is stopped due a fatal error and can be retried
    FAILED = 12;
    // Playback is interrupted by an ad
    INTERRUPTED_BY_AD = 13;
    // Playback is abandoned before reaching the end of the media
    ABANDONED = 14;
}

enum PlaybackErrorCode {
    ERROR_CODE_UNKNOWN = 0;
    ERROR_CODE_OTHER = 1;
    ERROR_CODE_RUNTIME = 2;
    ERROR_CODE_NETWORK_OFFLINE = 3;
    ERROR_CODE_NETWORK_CONNECT = 4;
    ERROR_CODE_NETWORK_BAD_STATUS = 5;
    ERROR_CODE_NETWORK_DNS = 6;
    ERROR_CODE_NETWORK_TIMEOUT = 7;
    ERROR_CODE_NETWORK_CLOSED = 8;
    ERROR_CODE_NETWORK_OTHER = 9;
    ERROR_CODE_MEDIA_MANIFET = 10;
    ERROR_CODE_MEDIA_PARSER = 11;
    ERROR_CODE_MEDIA_OTHER = 12;
    ERROR_CODE_DECODER_INIT = 13;
    ERROR_CODE_DECODER_DECODE = 14;
    ERROR_CODE_DECODER_OOM = 15;
    ERROR_CODE_DECODER_OTHER = 16;
    ERROR_CODE_AUDIOTRACK_INIT = 17;
    ERROR_CODE_AUDIOTRACK_WRITE = 18;
    ERROR_CODE_AUDIOTRACK_OTHER = 19;
    ERROR_CODE_PLAYER_REMOTE = 20;
    ERROR_CODE_PLAYER_BEHIND_LIVE_WINDOW = 21;
    ERROR_CODE_PLAYER_OTHER = 22;
    ERROR_CODE_DRM_UNAVAILABLE = 23;
    ERROR_CODE_DRM_PROVISIONING_FAILED = 24;
    ERROR_CODE_DRM_LICENSE_ERROR = 25;
    ERROR_CODE_DRM_DISALLOWED = 26;
    ERROR_CODE_DRM_SYSTEM_ERROR = 27;
    ERROR_CODE_DRM_CONTENT_ERROR = 28;
    ERROR_CODE_DRM_REVOKED = 39;
    ERROR_CODE_DRM_OTHER = 30;
}

enum TrackType {
    AUDIO = 0;
    VIDEO = 1;
    TEXT = 2;
}
enum TrackState {
    OFF = 0;
    ON = 1;
}
enum TrackChangeReason {
    REASON_UNKNOWN = 0;
    REASON_OTHER = 1;
    REASON_INITIAL = 2;
    REASON_MANUAL = 3;
    REASON_ADAPTIVE = 4;
}
